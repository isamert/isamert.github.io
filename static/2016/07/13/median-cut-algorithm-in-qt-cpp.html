<!DOCTYPE html>
<head>
  <title>Median cut algorithm in Qt/C++ | isamert.net</title>

  <!-- highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>

  <script>
   document.addEventListener('DOMContentLoaded', () => {
     addLinksToHeaders()
     highlightCodeBlocks()
   })

   function addLinksToHeaders() {
     document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(h => {
       if (!h.hasAttribute('id')) {
         return
       }

       const a = document.createElement('a')
       a.setAttribute('href', '#' + h.id)
       a.classList.add('clear')
       h.parentNode.replaceChild(a, h)
       a.appendChild(h)
     })
   }

   function highlightCodeBlocks(_event) {
     let pageLang

     // Higlight all code blocks
     document.querySelectorAll('pre.src').forEach(block => {
       const lang = [...block.classList].find(x => x.startsWith('src-'))
       if (lang) {
         const currLang = lang.split('-')[1]
         if (currLang) {
           pageLang = currLang
           block.classList.add(pageLang)
         }
       }
       hljs.highlightBlock(block)
     })

     // Highlight all inline code blocks
     document.querySelectorAll('code').forEach(block => {
       if (pageLang) {
         block.classList.add(pageLang)
       }
       hljs.highlightBlock(block)
     })
   }
  </script>

  <style>

   /* Fonts */
   /* @import url('https://fonts.googleapis.com/css2?family=Fira+Sans&family=Fira+Sans+Condensed&display=swap'); */
   /* @import url('https://fonts.googleapis.com/css2?family=Dosis:wght@300&display=swap'); */
   /* @import url('https://fonts.googleapis.com/css2?family=Merriweather&display=swap'); */
   @import url('https://fonts.googleapis.com/css2?family=Gentium+Book+Basic&display=swap');
   @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap');

   /*
      Primary #545759
      Light #808486
      Dark #2b2e30

      Secondary #864ac6
      Light #b978fa
      Dark #541c95
    */

   body {
     /* font-family: 'Fira Sans Condensed', sans-serif; */
     /* font-family: 'Merriweather', serif; */
     font-family: 'Gentium Book Basic', serif;
     color: #545759;
     margin: 0;
     padding: 0;
   }

   header {
     position: fixed;
     width: 100%;
     top: 0;
     background-color: #f8f7f3;
     padding: 1rem 3.5rem;
     display: block;
     box-shadow: 3px 3px 2px #aaaaaa;
   }

   header > a {
     font-weight: bold;
   }

   section {
     margin-top: 3.5rem !important;
     margin: 3rem auto;
     max-width: 100%;
     line-height: 1.5;
     padding: 0 10px;
   }

   footer {
     max-width: 100%;
     margin-right: auto;
     margin-left: auto;
   }

   footer > p {
     text-align: left;
   }

   footer > p > span {
      float: right;
   }

   h1, h2, h3, h4, h5, h6, h7 {
     /* font-family: 'Dosis', sans-serif; */
     /* font-family: 'Merriweather', serif; */
     font-size: 1.3rem;
     line-height: 1.65;
     color: #2b2e30;
   }

   h1 {
     font-size: 2em;
     border-bottom: 1.7px dashed #808486;
   }

   h2 {
     font-size: 1.7em;
     border-bottom: 1.5px dashed #808486;
   }

   h3 {
     font-size: 1.5em;
     border-bottom: 1px dashed #808486;
   }

   h4 {
     font-size: 1.3em;
     border-bottom: 1px dashed #808486; /* TODO: Maybe remove this */
   }

   h5 {
     font-size: 1.2em;
   }

   h1:hover, h2:hover, h3:hover, h4:hover {
     color: #808486;
     cursor: pointer;
   }

   .clear {
     color: inherit;
     text-decoration: inherit;
   }

   blockquote {
     border-left: 1.4px solid  #808486;
     margin: 0;
     margin-left: 1rem;
     padding: 0 0 0 20px;
     font-style: italic;
   }

   a {
     color: #545759;
     text-decoration-color: #545759;
     text-decoration-style: dotted;
     text-decoration-thickness: 0.130em;
     text-underline-offset: 1.5px;
   }

   a:hover {
     color: #808486;
     text-decoration-color: #808486;
     text-decoration-style: wavy;
     text-decoration-thickness: 0.1rem;
   }

   /* Inline codes */
   code {
     font-family: "IBM Plex Mono", monospace;
     font-size: 0.7em;
     background: #f8f7f3 !important;
     border-radius: 0.4rem !important;
     padding: 0.24rem !important;
   }

   /*
    * Make code blocks in paragraphs inline.
    * hljs turns them into a fully-fledged code block. We don't want that.
    */
   code {
     display: inline !important;
   }

   /* Code blocks */
   .src, .example {
     font-size: 0.85em;
     font-family: "IBM Plex Mono", monospace;
     background: #f3f2ee;
     padding: .4rem .7rem !important;
     border-radius: 0.3rem !important;
     display: block !important;
   }

   /* Add responsiveness */
   @media screen and (min-width: 640px) {
     section, footer {
       max-width: 100%;
       padding: 10px;
     }
   }

   @media screen and (min-width: 768px) {
     section, footer {
       max-width: 80%;
       padding: 10px;
     }
   }

   @media screen and (min-width: 1024px) {
     section, footer {
       max-width: 55%;
       padding: 10px;
     }
   }
  </style>
</head>

<body>
  <header>
      <!-- TODO: right links like RSS About etc. -->
      <a href="/index.html">isamert.net</a>  |
  </header>

  <section>
    <h1>Median cut algorithm in Qt/C++</h1>
    <p>
I needed a simple color quantization algorithm for my project. I didn't want to use any other program/library for this simple job. So I implemented <i>median cut</i> with <i>Qt</i>. I just used the explanation of the algorithm in <a href="https://en.wikipedia.org/wiki/Median_cut">Wikipedia</a>, I didn't make any other research, so the code is not well optimized but it just works. I'll try to explain step by step:
</p>

<p>
We have an image with an arbitrary number of pixels and want to generate a palette of <b>X</b> colors. The very first thing we need to is putting all the pixels in a list. By <i>pixels</i>, I mean their RGB data. Then we need to find the color channel(red, green, blue) that has the most wide range. Let's implement this:
</p>

<div class="org-src-container">
<pre class="src src-cpp">QString filePath = "some_image.png";
int color_count = 256; // The color count that we want to reduce our image.

QList&lt;QRgb&gt; pixels;
QImage img(filePath);

// For finding color channel that has the most wide range,
// we need to keep their lower and upper bound.
int lower_red   = qRed(img.pixel(0, 0)),
    lower_green = qGreen(img.pixel(0, 0)),
    lower_blue  = qBlue(img.pixel(0, 0));
int upper_red   = 0,
    upper_green = 0,
    upper_blue  = 0;

// Just loop trough all the pixels
for (int x = 0; x &lt; img.width(); ++x) {
    for (int y = 0; y &lt; img.height(); ++y) {
        QRgb rgb = img.pixel(x, y);         // Get rgb data of a particular pixel
        if (!pixels.contains(rgb)) {        // If we have the same pixel, we don't need it twice or more
            lower_red = std::min(lower_red, qRed(rgb));
            lower_green = std::min(lower_green, qGreen(rgb));
            lower_blue = std::min(lower_blue, qBlue(rgb));

            upper_red = std::max(upper_red, qRed(rgb));
            upper_green = std::max(upper_green, qGreen(rgb));
            upper_blue = std::max(upper_blue, qBlue(rgb));
            pixels.append(rgb);
        }
    }
}
</pre>
</div>

<p>
We have upper bounds and lower bounds of the color channels, so just find out the one that has widest range:
</p>

<div class="org-src-container">
<pre class="src src-cpp">int red = upper_red - lower_red;
int green = upper_green - lower_green;
int blue = upper_blue - lower_blue;
int max = std::max(std::max(red, green), blue);
</pre>
</div>

<p>
Then we need to short our <i>pixels</i> list according to the channel we just found out. <i>For example, if the blue channel has the greatest range, then a pixel with an RGB value of (32, 8, 16) is less than a pixel with an RGB value of (1, 2, 24), because 16 &lt; 24.</i>
</p>

<div class="org-src-container">
<pre class="src src-cpp">qSort(pixels.begin(), pixels.end(), [max,red,green,blue](const QRgb&amp; rgb1, const QRgb&amp; rgb2){
    if (max == red)  // if red is our color that has the widest range
        return qRed(rgb1) &lt; qRed(rgb2); // just compare their red channel
    else if (max == green) //...
        return qGreen(rgb1) &lt; qRed(rgb2);
    else /*if (max == blue)*/
        return qBlue(rgb1) &lt; qBlue(rgb2);
});
// We just used qSort here.
// As comparison function, we sent a lambda function
// that compares two rgb color according to our selected color channel.
</pre>
</div>

<p>
After sorting our list, we need to move the upper half of the list to another list, then we have two list. For these two list, we will do the same thing until we get <b>X</b> lists (So if we want to reduce our color palette to 16 colors, we need to repeat this step until we get 16 lists.).
</p>

<div class="org-src-container">
<pre class="src src-cpp">QList&lt;QList&lt;QRgb&gt;&gt; lists;
int list_size = pixels.size() / color_count;

for (int i = 0; i &lt; color_count; ++i) {
    QList&lt;QRgb&gt; list;
    for (int j = list_size * i; j &lt; (list_size * i) + list_size; ++j) {
        list.append(pixels.at(j));
    }
    lists.append(list);
}
</pre>
</div>

<p>
We got our lists. After that, we can get the average of each list and we can build our <b>X</b> colored palette or we can just get the median of each list. I didn't observe so much difference, so I'm going with the easy one.
</p>

<div class="org-src-container">
<pre class="src src-cpp">QVector&lt;QRgb&gt; palette;
for (QList&lt;QRgb&gt; list: lists) {
    palette.append(list.at(list.size() / 2));
}
</pre>
</div>

<p>
We build up our X color palette. The next thing I am going to do is convert our original image color palette to our new palette. Actually there is a Qt function for that but it has a <i>bug</i>.(I'll explain it later) So we need to implement this.
</p>

<div class="org-src-container">
<pre class="src src-cpp">QVector&lt;QRgb&gt; palette;
for (QList&lt;QRgb&gt; list: lists) {
    palette.append(list.at(list.size() / 2));
}

QImage out(img.width(), img.height(), QImage::Format_ARGB32);
for (int x = 0; x &lt; img.width(); ++x) {
    for (int y = 0; y &lt; img.height(); ++y) {
    out.setPixel(x,y, palette[closestMatch(img.pixel(x, y), palette)]);
    }
}
</pre>
</div>

<p>
In this piece of code, we just create a <code>QImage</code> that has same size of our original image and format. Then we loop through all the pixels in our original image and find the closest color from our new palette then set that color to corresponding pixel of our new <code>QImage</code> object. And that's it.
</p>

<p>
There is one function that needs explanation in this code, closestMatch. I just took it from the Qt source code. Actually, <code>QImage</code> has a function named convertToFormat. You can use this function to change the format of your image and also it lets you to change color palette of your image. The function definition goes like this: <code>QImage QImage::convertToFormat(Format format, const QVector&lt;QRgb&gt; &amp;colorTable, Qt::ImageConversionFlags flags = Qt::AutoColor) const</code> and it's definition says:
</p>

<blockquote>
<p>
Returns a copy of the image converted to the given format, using the specified colorTable. Conversion from 32 bit to 8 bit indexed is a slow operation and will use a straightforward nearest color approach, with no dithering.
</p>
</blockquote>

<p>
So we can simply use this function to convert any image using our palette. But there is a one problem, if you don't want to change your image format(so your source and output image has the same format), it just simply returns the image itself without converting to our palette. So I extracted the part that it finds the closest color to given color from a vector:
</p>

<div class="org-src-container">
<pre class="src src-cpp">static inline int pixel_distance(QRgb p1, QRgb p2) {
    int r1 = qRed(p1);
    int g1 = qGreen(p1);
    int b1 = qBlue(p1);
    int a1 = qAlpha(p1);

    int r2 = qRed(p2);
    int g2 = qGreen(p2);
    int b2 = qBlue(p2);
    int a2 = qAlpha(p2);

    return abs(r1 - r2) + abs(g1 - g2) + abs(b1 - b2) + abs(a1 - a2);
}

static inline int closestMatch(QRgb pixel, const QVector&lt;QRgb&gt; &amp;clut) {
    int idx = 0;
    int current_distance = INT_MAX;
    for (int i=0; i&lt;clut.size(); ++i) {
        int dist = pixel_distance(pixel, clut.at(i));
        if (dist &lt; current_distance) {
            current_distance = dist;
            idx = i;
        }
    }
    return idx;
}
</pre>
</div>

  </section>

  <footer>
    <hr />
    <p>
      Isa Mert Gurbuz <a href="mailto:isamert@protonmail.com">&lt;isamert@protonmail.com&gt;</a>

      <span>
        Check out the <a href="https://github.com/isamert/isamert.github.io">source</a>.
      </span>
    </p>
  </footer>
</body>
